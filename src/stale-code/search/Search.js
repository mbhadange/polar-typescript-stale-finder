"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const libpath = __importStar(require("path"));
const fs = __importStar(require("fs"));
const FilePaths_1 = require("polar-shared/src/util/FilePaths");
const readline = __importStar(require("readline"));
const path = __importStar(require("path"));
class Search {
    static find(dir, opts = new DefaultOpts()) {
        const files = fs.readdirSync(dir);
        const result = [];
        for (const name of files) {
            const path = libpath.join(dir, name);
            const stat = fs.statSync(path);
            const createType = () => {
                if (stat.isDirectory()) {
                    return 'directory';
                }
                if (stat.isFile()) {
                    return 'file';
                }
                return undefined;
            };
            const type = createType();
            if (!type) {
                continue;
            }
            const createRecord = () => {
                return { type, name, path };
            };
            const file = createRecord();
            const acceptFile = () => {
                const acceptExtension = () => {
                    if (!opts.extensions) {
                        return true;
                    }
                    const ext = FilePaths_1.FilePaths.toExtension(path).getOrUndefined();
                    return ext && opts.extensions.includes(ext);
                };
                const acceptType = () => {
                    if (!opts.types) {
                        return true;
                    }
                    return opts.types.includes(type);
                };
                return acceptExtension() && acceptType();
            };
            if (acceptFile()) {
                result.push(file);
            }
            if (opts.recurse && type === 'directory') {
                result.push(...this.find(path, opts));
            }
        }
        return result;
    }
}
exports.Search = Search;
class DefaultOpts {
    constructor() {
        this.recurse = true;
        this.types = ['file'];
    }
}
let hitMap = new Map();
let opts = new DefaultOpts();
let rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.question('Enter the entire directory path to be parsed through: ', (currDirectory) => {
    var fileMap = Search.find(currDirectory, opts);
    for (var i = 0; i < fileMap.length; i++) {
        var file = fileMap[i];
        var initialFileName = file.name;
        var initialFilePath = file.path;
        if (file.name === 'test.ts') {
            continue;
        }
        else if (initialFileName.split('.').pop() === 'ts' || initialFileName.split('.').pop() === 'tsx') {
            const data = fs.readFileSync(initialFilePath, 'utf8');
            const lines = data.split(/\r?\n/);
            let re = /import(?:["'\s]*([\w*{}\n\r\t, ]+)from\s*)?["'\s].*([@\w_-]+)["'\s].*;$/;
            lines.forEach((line) => {
                let importLine = line.match(re);
                if (importLine != null) {
                    let importVal = importLine[0];
                    let filePath = importVal.split(' ').pop();
                    var fullPath;
                    if (filePath != undefined) {
                        fullPath = path.resolve(initialFilePath, filePath);
                    }
                    if (hitMap.has(fullPath) === true) {
                        var currVal = hitMap.get(fullPath);
                        hitMap.set(fullPath, currVal + 1);
                    }
                    else {
                        hitMap.set(fullPath, 1);
                    }
                }
            });
        }
    }
    hitMap[Symbol.iterator] = function* () {
        yield* [...this.entries()].sort((a, b) => a[1] - b[1]);
    };
    var updatedHitMap = [...hitMap];
    var finalHitMap = [];
    for (var index = 0; index < updatedHitMap.length; index++) {
        var currentArray = updatedHitMap[index];
        var key = currentArray[0];
        var value = currentArray[1];
        finalHitMap[index] = [value, key];
    }
    console.log(finalHitMap);
    rl.close();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiU2VhcmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBLDhDQUFnQztBQUNoQyx1Q0FBeUI7QUFDekIsK0RBQTBEO0FBRTFELG1EQUFxQztBQUNyQywyQ0FBNkI7QUFFN0IsTUFBYSxNQUFNO0lBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFXLEVBQUUsT0FBYSxJQUFJLFdBQVcsRUFBRTtRQUMxRCxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sTUFBTSxHQUFZLEVBQUUsQ0FBQztRQUUzQixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtZQUV0QixNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNyQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRS9CLE1BQU0sVUFBVSxHQUFHLEdBQXlCLEVBQUU7Z0JBQzFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO29CQUNwQixPQUFPLFdBQVcsQ0FBQztpQkFDdEI7Z0JBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUU7b0JBQ2YsT0FBTyxNQUFNLENBQUM7aUJBQ2pCO2dCQUNELE9BQU8sU0FBUyxDQUFDO1lBQ3JCLENBQUMsQ0FBQztZQUNGLE1BQU0sSUFBSSxHQUFHLFVBQVUsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBRSxJQUFJLEVBQUU7Z0JBQ1IsU0FBUzthQUNaO1lBQ0QsTUFBTSxZQUFZLEdBQUcsR0FBVSxFQUFFO2dCQUM3QixPQUFPLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQztZQUM5QixDQUFDLENBQUM7WUFFRixNQUFNLElBQUksR0FBRyxZQUFZLEVBQUUsQ0FBQztZQUs1QixN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O0lBQ3JCLEtBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQ3ZELElBQUksWUFBWSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QyxJQUFJLEdBQUcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxLQUFLLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNyQztJQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDekIsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ2YsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXJybm9FeGNlcHRpb24gPSBOb2RlSlMuRXJybm9FeGNlcHRpb247XG5pbXBvcnQgKiBhcyBsaWJwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7RmlsZVBhdGhzfSBmcm9tIFwicG9sYXItc2hhcmVkL3NyYy91dGlsL0ZpbGVQYXRoc1wiO1xuaW1wb3J0IHtQYXRoU3RyfSBmcm9tIFwicG9sYXItc2hhcmVkL3NyYy91dGlsL1N0cmluZ3NcIjtcbmltcG9ydCAqIGFzIHJlYWRsaW5lIGZyb20gJ3JlYWRsaW5lJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2gge1xuICAgIHB1YmxpYyBzdGF0aWMgZmluZChkaXI6IHN0cmluZywgb3B0czogT3B0cyA9IG5ldyBEZWZhdWx0T3B0cygpKTogUmVhZG9ubHlBcnJheTxJRmlsZT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBJRmlsZVtdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBsaWJwYXRoLmpvaW4oZGlyLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhwYXRoKTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlVHlwZSA9ICgpOiBGaWxlVHlwZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RpcmVjdG9yeSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmaWxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gY3JlYXRlVHlwZSgpO1xuICAgICAgICAgICAgaWYgKCEgdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVjb3JkID0gKCk6IElGaWxlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGUsIG5hbWUsIHBhdGh9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGNyZWF0ZVJlY29yZCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybiB0cnVlIGlmIHdlIHNob3VsZCBhY2NlcHQgdGhlIGZpbGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGFjY2VwdEZpbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXB0RXh0ZW5zaW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISBvcHRzLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IEZpbGVQYXRocy50b0V4dGVuc2lvbihwYXRoKS5nZXRPclVuZGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ICYmIG9wdHMuZXh0ZW5zaW9ucy5pbmNsdWRlcyhleHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXB0VHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgb3B0cy50eXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMudHlwZXMuaW5jbHVkZXModHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXB0RXh0ZW5zaW9uKCkgJiYgYWNjZXB0VHlwZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChhY2NlcHRGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlY3Vyc2UgJiYgdHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi50aGlzLmZpbmQocGF0aCwgb3B0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vLy8gdGhlIGZpbGUgdHlwZSB0aGF0IGlzIGNvbXBhdGliYWxlXG5leHBvcnQgdHlwZSBGaWxlVHlwZSA9ICdmaWxlJyB8ICdkaXJlY3RvcnknO1xuLy8vIEEgZmlsZSBleHRlbnNpb24gd2l0aG91dCB0aGUgJy4nIHByZWZpeC4gIEV4YW1wbGU6IGpwZywganBlZywgdHh0XG5leHBvcnQgdHlwZSBGaWxlRXh0ID0gc3RyaW5nO1xuXG5jbGFzcyBEZWZhdWx0T3B0cyBpbXBsZW1lbnRzIE9wdHMge1xuICAgIHB1YmxpYyByZWFkb25seSByZWN1cnNlID0gdHJ1ZTtcbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZXM6IFJlYWRvbmx5QXJyYXk8RmlsZVR5cGU+ID0gWydmaWxlJ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0cyB7XG4gICAgcmVhZG9ubHkgcmVjdXJzZT86IGJvb2xlYW47XG4gICAgLy8vIE9ubHkgYWNjZXB0IHRoZSBnaXZlbiBmaWxlIHR5cGVzLiAgQnkgZGVmYXVsdCBhbGwgdHlwZXMgYXJlIGFjY2VwdGVkLlxuICAgIHJlYWRvbmx5IHR5cGVzPzogUmVhZG9ubHlBcnJheTxGaWxlVHlwZT47IFxuICAgIC8vLyBPbmx5IGFjY2VwdCB0aGUgZ2l2ZW4gZXh0ZW5zaW9ucy4gQnkgZGVmYXVsdCBhbGwgZXh0ZW5zaW9uIGFyZSBhY2NlcHRlZC5cbiAgICByZWFkb25seSBleHRlbnNpb25zPzogUmVhZG9ubHlBcnJheTxGaWxlRXh0PjsgXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpbGUge1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZzsgXG4gICAgcmVhZG9ubHkgcGF0aDogUGF0aFN0cjsgLy8vIHRoZSBlbnRpcmUgcGF0aCBvZiB0aGUgZmlsZVxuICAgIHJlYWRvbmx5IHR5cGU6IEZpbGVUeXBlOyAvLy8gd2hhdCB0eXBlIHRoZSBmaWxlIGlzXG59XG5cbi8vLyBjcmVhdGVzIGFuIGVtcHR5IG1hcFxubGV0IGhpdE1hcCA9IG5ldyBNYXAoKTtcbmxldCBvcHRzID0gbmV3IERlZmF1bHRPcHRzKCk7XG4vLy8gYWxsb3dzIHVzIHRvIHRha2UgdXNlciBpbnB1dFxubGV0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICBpbnB1dDogcHJvY2Vzcy5zdGRpbixcbiAgICBvdXRwdXQ6IHByb2Nlc3Muc3Rkb3V0XG59KTtcblxuLyoqXG4gKiBhc2tzIHVzZXIgdG8gc2VlIHdoaWNoIGRpcmVjdG9yeSB0byBwYXJzZSB0aHJvdWdoXG4gKiBleGFtcGxlOiAvVXNlcnMvbWloaXJtYWNwcm8xMy9Eb2N1bWVudHMvR2l0SHViL3N0YWxlLWZpbmRlci10ZXN0LWRpcmVjdG9yeS9cbiAqLyBcbnJsLnF1ZXN0aW9uKCdFbnRlciB0aGUgZW50aXJlIGRpcmVjdG9yeSBwYXRoIHRvIGJlIHBhcnNlZCB0aHJvdWdoOiAnLCAoY3VyckRpcmVjdG9yeSkgPT4ge1xuICAgIC8vLyBTZWFyY2guZmluZCByZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHRoZSBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5XG4gICAgLy8vIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAgICB2YXIgZmlsZU1hcCA9IFNlYXJjaC5maW5kKGN1cnJEaXJlY3RvcnksIG9wdHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLy8gbWFwIG9mIHRoZSBmaWxlIHR5cGUsIG5hbWUsIHBhdGggXG4gICAgICAgIHZhciBmaWxlID0gZmlsZU1hcFtpXTtcbiAgICAgICAgdmFyIGluaXRpYWxGaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgdmFyIGluaXRpYWxGaWxlUGF0aCA9IGZpbGUucGF0aDtcblxuICAgICAgICAvLy8gY2hlY2tzIHRvIHNlZSBpZiB0aGUgZmlsZSBuYW1lIGlzIHRlc3QudHNcbiAgICAgICAgLy8vIGlmIGl0IGlzIHRoZW4gY29udGludWVzIHRvIHRoZSBuZXh0IGZpbGVcbiAgICAgICAgaWYgKGZpbGUubmFtZSA9PT0gJ3Rlc3QudHMnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLy8gY2hlY2tzIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaWxlIHR5cGUgaXMgZWl0aGVyIC50cyBvciAudHN4XG4gICAgICAgIGVsc2UgaWYgKGluaXRpYWxGaWxlTmFtZS5zcGxpdCgnLicpLnBvcCgpID09PSAndHMnIHx8IGluaXRpYWxGaWxlTmFtZS5zcGxpdCgnLicpLnBvcCgpID09PSAndHN4Jykge1xuICAgICAgICAgICAgLy8vIGdldHMgYWxsIHRoZSBjb250ZW50cyBvZiB0aGUgY3VycmVudCBmaWxlXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGluaXRpYWxGaWxlUGF0aCwndXRmOCcpO1xuICAgICAgICAgICAgLy8vIHNwbGl0cyBlYWNoIGxpbmUgb2YgZGF0YSB0byBhbGxvdyB1cyB0byBwYXJzZSB0aHJvdWdoIGVhY2ggb25lXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGRhdGEuc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgICAgIC8vLyBjcmVhdGVzIGEgcmVndWxhciBleHByZXNzaW9uIGZvciB0aGUgaW1wb3J0IGxpbmVzXG4gICAgICAgICAgICBsZXQgcmUgPSAvaW1wb3J0KD86W1wiJ1xcc10qKFtcXHcqe31cXG5cXHJcXHQsIF0rKWZyb21cXHMqKT9bXCInXFxzXS4qKFtAXFx3Xy1dKylbXCInXFxzXS4qOyQvO1xuICAgICAgICAgICAgLy8vIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBsaW5lIG9mIHRoZSBmaWxlXG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8vIGNoZWNrcyB0byBzZWUgaWYgdGhlIGxpbmUgbWF0Y2hlcyB0aGUgZm9ybWF0IG9mIHRoZSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBsZXQgaW1wb3J0TGluZSA9IGxpbmUubWF0Y2gocmUpO1xuICAgICAgICAgICAgICAgIC8vLyBtYWtlcyBzdXJlIHRoYXQgdGhlIGxpbmUgYWN0dWFsbHkgaGFzIHRoZSBwcm9wZXIgZm9ybWF0IG9mIHRoZSByZWdFeFxuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8vIGdldHMgdGhlIGVudGlyZSBpbXBvcnQgbGluZXMgY29udGVudHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltcG9ydFZhbCA9IGltcG9ydExpbmVbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vLyBzcGxpdHMgdGhlIGxpbmUgYmFzZWQgb2ZmIHNwYWNlcyBhbmQgZ2V0cyBvbmx5IHRoZSBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVQYXRoID0gaW1wb3J0VmFsLnNwbGl0KCcgJykucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8vIGNvbnZlcnRzIHRoYXQgZmlsZSBwYXRoIGludG8gYSBmdWxsIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVBhdGggIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShpbml0aWFsRmlsZVBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLy8gY2hlY2tzIHRvIHNlZSBpZiB0aGUgaGl0bWFwIGFscmVhZHkgaGFzIHRoYXQgcGF0aFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGl0TWFwLmhhcyhmdWxsUGF0aCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLyBpZiBpdCBkb2VzIHRoZW4gaW5jcmVtZW50cyB0aGUgdmFsdWUgb2YgdGhhdCBmaWxlIGJ5IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmFsID0gaGl0TWFwLmdldChmdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRNYXAuc2V0KGZ1bGxQYXRoLCBjdXJyVmFsICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8vIGlmIHRoZSBoaXRtYXAgZG9lcyBub3QgaGF2ZSB0aGF0IHBhdGggYXMgYSBrZXkgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLyB0aGVuIHNldHMgdGhhdCBmaWxlIHBhdGggdG8gaGF2ZSBhIHZhbHVlIG9mIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdE1hcC5zZXQoZnVsbFBhdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgbWFwIGluIG9yZGVyIGJhc2VkIG9uIHRoZSB2YWx1ZXMgXG4gICAgICovXG4gICAgaGl0TWFwW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCogWy4uLnRoaXMuZW50cmllcygpXS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgfVxuICAgIFxuICAgIHZhciB1cGRhdGVkSGl0TWFwID0gWy4uLmhpdE1hcF07XG5cbiAgICB2YXIgZmluYWxIaXRNYXAgPSBbXTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdXBkYXRlZEhpdE1hcC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRBcnJheSA9IHVwZGF0ZWRIaXRNYXBbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudEFycmF5WzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBjdXJyZW50QXJyYXlbMV07XG4gICAgICAgIGZpbmFsSGl0TWFwW2luZGV4XSA9IFt2YWx1ZSwga2V5XTtcbiAgICB9XG4gICAgLy8vIHByaW50cyBvdXQgdGhlIGhpdE1hcFxuICAgIGNvbnNvbGUubG9nKGZpbmFsSGl0TWFwKTsgXG4gICAgcmwuY2xvc2UoKTtcbn0pO1xuXG4iXX0=