"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const libpath = __importStar(require("path"));
const fs = __importStar(require("fs"));
const FilePaths_1 = require("polar-shared/src/util/FilePaths");
const readline = __importStar(require("readline"));
const path = __importStar(require("path"));
class Search {
    static find(dir, opts = new DefaultOpts()) {
        const files = fs.readdirSync(dir);
        const result = [];
        for (const name of files) {
            const path = libpath.join(dir, name);
            const stat = fs.statSync(path);
            const createType = () => {
                if (stat.isDirectory()) {
                    return 'directory';
                }
                if (stat.isFile()) {
                    return 'file';
                }
                return undefined;
            };
            const type = createType();
            if (!type) {
                continue;
            }
            const createRecord = () => {
                return { type, name, path };
            };
            const file = createRecord();
            const acceptFile = () => {
                const acceptExtension = () => {
                    if (!opts.extensions) {
                        return true;
                    }
                    const ext = FilePaths_1.FilePaths.toExtension(path).getOrUndefined();
                    return ext && opts.extensions.includes(ext);
                };
                const acceptType = () => {
                    if (!opts.types) {
                        return true;
                    }
                    return opts.types.includes(type);
                };
                return acceptExtension() && acceptType();
            };
            if (acceptFile()) {
                result.push(file);
            }
            if (opts.recurse && type === 'directory') {
                result.push(...this.find(path, opts));
            }
        }
        return result;
    }
}
exports.Search = Search;
class DefaultOpts {
    constructor() {
        this.recurse = true;
        this.types = ['file'];
    }
}
let hitMap = new Map();
let opts = new DefaultOpts();
let rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.question('Enter the entire directory path to be parsed through: ', (currDirectory) => {
    var fileMap = Search.find(currDirectory, opts);
    for (var i = 0; i < fileMap.length; i++) {
        var file = fileMap[i];
        var initialFileName = file.name;
        var initialFilePath = file.path;
        if (file.name === 'test.ts') {
            continue;
        }
        else if (initialFileName.split('.').pop() === 'ts' || initialFileName.split('.').pop() === 'tsx') {
            const data = fs.readFileSync(initialFilePath, 'utf8');
            const lines = data.split(/\r?\n/);
            let re = /import(?:["'\s]*([\w*{}\n\r\t, ]+)from\s*)?["'\s].*([@\w_-]+)["'\s].*;$/;
            lines.forEach((line) => {
                let importLine = line.match(re);
                if (importLine != null) {
                    let importVal = importLine[0];
                    let filePath = importVal.split(' ').pop();
                    var fullPath;
                    if (filePath != undefined) {
                        fullPath = path.resolve(initialFilePath, filePath);
                    }
                    if (hitMap.has(fullPath) === true) {
                        var currVal = hitMap.get(fullPath);
                        hitMap.set(fullPath, currVal + 1);
                    }
                    else {
                        hitMap.set(fullPath, 1);
                    }
                }
            });
        }
    }
    hitMap[Symbol.iterator] = function* () {
        yield* [...this.entries()].sort((a, b) => a[1] - b[1]);
    };
    console.log([...hitMap]);
    rl.close();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiU2VhcmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBLDhDQUFnQztBQUNoQyx1Q0FBeUI7QUFDekIsK0RBQTBEO0FBRTFELG1EQUFxQztBQUNyQywyQ0FBNkI7QUFFN0IsTUFBYSxNQUFNO0lBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFXLEVBQUUsT0FBYSxJQUFJLFdBQVcsRUFBRTtRQUMxRCxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sTUFBTSxHQUFZLEVBQUUsQ0FBQztRQUUzQixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtZQUV0QixNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNyQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRS9CLE1BQU0sVUFBVSxHQUFHLEdBQXlCLEVBQUU7Z0JBQzFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO29CQUNwQixPQUFPLFdBQVcsQ0FBQztpQkFDdEI7Z0JBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUU7b0JBQ2YsT0FBTyxNQUFNLENBQUM7aUJBQ2pCO2dCQUNELE9BQU8sU0FBUyxDQUFDO1lBQ3JCLENBQUMsQ0FBQztZQUNGLE1BQU0sSUFBSSxHQUFHLFVBQVUsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBRSxJQUFJLEVBQUU7Z0JBQ1IsU0FBUzthQUNaO1lBQ0QsTUFBTSxZQUFZLEdBQUcsR0FBVSxFQUFFO2dCQUM3QixPQUFPLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQztZQUM5QixDQUFDLENBQUM7WUFFRixNQUFNLElBQUksR0FBRyxZQUFZLEVBQUUsQ0FBQztZQUs1QixN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LEVBQUUsQ0FBQztBQUNmLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVycm5vRXhjZXB0aW9uID0gTm9kZUpTLkVycm5vRXhjZXB0aW9uO1xuaW1wb3J0ICogYXMgbGlicGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQge0ZpbGVQYXRoc30gZnJvbSBcInBvbGFyLXNoYXJlZC9zcmMvdXRpbC9GaWxlUGF0aHNcIjtcbmltcG9ydCB7UGF0aFN0cn0gZnJvbSBcInBvbGFyLXNoYXJlZC9zcmMvdXRpbC9TdHJpbmdzXCI7XG5pbXBvcnQgKiBhcyByZWFkbGluZSBmcm9tICdyZWFkbGluZSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5leHBvcnQgY2xhc3MgU2VhcmNoIHtcbiAgICBwdWJsaWMgc3RhdGljIGZpbmQoZGlyOiBzdHJpbmcsIG9wdHM6IE9wdHMgPSBuZXcgRGVmYXVsdE9wdHMoKSk6IFJlYWRvbmx5QXJyYXk8SUZpbGU+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhkaXIpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogSUZpbGVbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbGlicGF0aC5qb2luKGRpciwgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVR5cGUgPSAoKTogRmlsZVR5cGUgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RvcnknO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmlsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNyZWF0ZVR5cGUoKTtcbiAgICAgICAgICAgIGlmICghIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlY29yZCA9ICgpOiBJRmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlLCBuYW1lLCBwYXRofTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBjcmVhdGVSZWNvcmQoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBzaG91bGQgYWNjZXB0IHRoZSBmaWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBhY2NlcHRGaWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2VwdEV4dGVuc2lvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgb3B0cy5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBGaWxlUGF0aHMudG9FeHRlbnNpb24ocGF0aCkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dCAmJiBvcHRzLmV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2VwdFR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIG9wdHMudHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLnR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VwdEV4dGVuc2lvbigpICYmIGFjY2VwdFR5cGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYWNjZXB0RmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWN1cnNlICYmIHR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5maW5kKHBhdGgsIG9wdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLy8vIHRoZSBmaWxlIHR5cGUgdGhhdCBpcyBjb21wYXRpYmFsZVxuZXhwb3J0IHR5cGUgRmlsZVR5cGUgPSAnZmlsZScgfCAnZGlyZWN0b3J5Jztcbi8vLyBBIGZpbGUgZXh0ZW5zaW9uIHdpdGhvdXQgdGhlICcuJyBwcmVmaXguICBFeGFtcGxlOiBqcGcsIGpwZWcsIHR4dFxuZXhwb3J0IHR5cGUgRmlsZUV4dCA9IHN0cmluZztcblxuY2xhc3MgRGVmYXVsdE9wdHMgaW1wbGVtZW50cyBPcHRzIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVjdXJzZSA9IHRydWU7XG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGVzOiBSZWFkb25seUFycmF5PEZpbGVUeXBlPiA9IFsnZmlsZSddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdHMge1xuICAgIHJlYWRvbmx5IHJlY3Vyc2U/OiBib29sZWFuO1xuICAgIC8vLyBPbmx5IGFjY2VwdCB0aGUgZ2l2ZW4gZmlsZSB0eXBlcy4gIEJ5IGRlZmF1bHQgYWxsIHR5cGVzIGFyZSBhY2NlcHRlZC5cbiAgICByZWFkb25seSB0eXBlcz86IFJlYWRvbmx5QXJyYXk8RmlsZVR5cGU+OyBcbiAgICAvLy8gT25seSBhY2NlcHQgdGhlIGdpdmVuIGV4dGVuc2lvbnMuIEJ5IGRlZmF1bHQgYWxsIGV4dGVuc2lvbiBhcmUgYWNjZXB0ZWQuXG4gICAgcmVhZG9ubHkgZXh0ZW5zaW9ucz86IFJlYWRvbmx5QXJyYXk8RmlsZUV4dD47IFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGaWxlIHtcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7IFxuICAgIHJlYWRvbmx5IHBhdGg6IFBhdGhTdHI7IC8vLyB0aGUgZW50aXJlIHBhdGggb2YgdGhlIGZpbGVcbiAgICByZWFkb25seSB0eXBlOiBGaWxlVHlwZTsgLy8vIHdoYXQgdHlwZSB0aGUgZmlsZSBpc1xufVxuXG4vLy8gY3JlYXRlcyBhbiBlbXB0eSBtYXBcbmxldCBoaXRNYXAgPSBuZXcgTWFwKCk7XG5sZXQgb3B0cyA9IG5ldyBEZWZhdWx0T3B0cygpO1xuLy8vIGFsbG93cyB1cyB0byB0YWtlIHVzZXIgaW5wdXRcbmxldCBybCA9IHJlYWRsaW5lLmNyZWF0ZUludGVyZmFjZSh7XG4gICAgaW5wdXQ6IHByb2Nlc3Muc3RkaW4sXG4gICAgb3V0cHV0OiBwcm9jZXNzLnN0ZG91dFxufSk7XG5cbi8qKlxuICogYXNrcyB1c2VyIHRvIHNlZSB3aGljaCBkaXJlY3RvcnkgdG8gcGFyc2UgdGhyb3VnaFxuICogZXhhbXBsZTogL1VzZXJzL21paGlybWFjcHJvMTMvRG9jdW1lbnRzL0dpdEh1Yi9zdGFsZS1maW5kZXItdGVzdC1kaXJlY3RvcnkvXG4gKi8gXG5ybC5xdWVzdGlvbignRW50ZXIgdGhlIGVudGlyZSBkaXJlY3RvcnkgcGF0aCB0byBiZSBwYXJzZWQgdGhyb3VnaDogJywgKGN1cnJEaXJlY3RvcnkpID0+IHtcbiAgICAvLy8gU2VhcmNoLmZpbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeVxuICAgIC8vLyBpdGVyYXRlcyB0aHJvdWdoIGVhY2ggZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gICAgdmFyIGZpbGVNYXAgPSBTZWFyY2guZmluZChjdXJyRGlyZWN0b3J5LCBvcHRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8vIG1hcCBvZiB0aGUgZmlsZSB0eXBlLCBuYW1lLCBwYXRoIFxuICAgICAgICB2YXIgZmlsZSA9IGZpbGVNYXBbaV07XG4gICAgICAgIHZhciBpbml0aWFsRmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgIHZhciBpbml0aWFsRmlsZVBhdGggPSBmaWxlLnBhdGg7XG5cbiAgICAgICAgLy8vIGNoZWNrcyB0byBzZWUgaWYgdGhlIGZpbGUgbmFtZSBpcyB0ZXN0LnRzXG4gICAgICAgIC8vLyBpZiBpdCBpcyB0aGVuIGNvbnRpbnVlcyB0byB0aGUgbmV4dCBmaWxlXG4gICAgICAgIGlmIChmaWxlLm5hbWUgPT09ICd0ZXN0LnRzJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8vIGNoZWNrcyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZmlsZSB0eXBlIGlzIGVpdGhlciAudHMgb3IgLnRzeFxuICAgICAgICBlbHNlIGlmIChpbml0aWFsRmlsZU5hbWUuc3BsaXQoJy4nKS5wb3AoKSA9PT0gJ3RzJyB8fCBpbml0aWFsRmlsZU5hbWUuc3BsaXQoJy4nKS5wb3AoKSA9PT0gJ3RzeCcpIHtcbiAgICAgICAgICAgIC8vLyBnZXRzIGFsbCB0aGUgY29udGVudHMgb2YgdGhlIGN1cnJlbnQgZmlsZVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhpbml0aWFsRmlsZVBhdGgsJ3V0ZjgnKTtcbiAgICAgICAgICAgIC8vLyBzcGxpdHMgZWFjaCBsaW5lIG9mIGRhdGEgdG8gYWxsb3cgdXMgdG8gcGFyc2UgdGhyb3VnaCBlYWNoIG9uZVxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBkYXRhLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgICAgICAvLy8gY3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIGltcG9ydCBsaW5lc1xuICAgICAgICAgICAgbGV0IHJlID0gL2ltcG9ydCg/OltcIidcXHNdKihbXFx3Knt9XFxuXFxyXFx0LCBdKylmcm9tXFxzKik/W1wiJ1xcc10uKihbQFxcd18tXSspW1wiJ1xcc10uKjskLztcbiAgICAgICAgICAgIC8vLyBpdGVyYXRlcyB0aHJvdWdoIGVhY2ggbGluZSBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vLyBjaGVja3MgdG8gc2VlIGlmIHRoZSBsaW5lIG1hdGNoZXMgdGhlIGZvcm1hdCBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgbGV0IGltcG9ydExpbmUgPSBsaW5lLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICAvLy8gbWFrZXMgc3VyZSB0aGF0IHRoZSBsaW5lIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVyIGZvcm1hdCBvZiB0aGUgcmVnRXhcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0TGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vLyBnZXRzIHRoZSBlbnRpcmUgaW1wb3J0IGxpbmVzIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbXBvcnRWYWwgPSBpbXBvcnRMaW5lWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLy8gc3BsaXRzIHRoZSBsaW5lIGJhc2VkIG9mZiBzcGFjZXMgYW5kIGdldHMgb25seSB0aGUgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlUGF0aCA9IGltcG9ydFZhbC5zcGxpdCgnICcpLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlUGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGluaXRpYWxGaWxlUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vLyBjb252ZXJ0cyB0aGF0IGZpbGUgcGF0aCBpbnRvIGEgZnVsbCBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgLy8vdmFyIGZ1bGxQYXRoID0gX19kaXJuYW1lICsgZmlsZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vLyBjaGVja3MgdG8gc2VlIGlmIHRoZSBoaXRtYXAgYWxyZWFkeSBoYXMgdGhhdCBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXRNYXAuaGFzKGZ1bGxQYXRoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8vIGlmIGl0IGRvZXMgdGhlbiBpbmNyZW1lbnRzIHRoZSB2YWx1ZSBvZiB0aGF0IGZpbGUgYnkgMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJWYWwgPSBoaXRNYXAuZ2V0KGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdE1hcC5zZXQoZnVsbFBhdGgsIGN1cnJWYWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLy8gaWYgdGhlIGhpdG1hcCBkb2VzIG5vdCBoYXZlIHRoYXQgcGF0aCBhcyBhIGtleSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8vIHRoZW4gc2V0cyB0aGF0IGZpbGUgcGF0aCB0byBoYXZlIGEgdmFsdWUgb2YgMVxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0TWFwLnNldChmdWxsUGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBtYXAgaW4gb3JkZXIgYmFzZWQgb24gdGhlIHZhbHVlcyBcbiAgICAgKi9cbiAgICBoaXRNYXBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkKiBbLi4udGhpcy5lbnRyaWVzKCldLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICB9XG4gICAgXG4gICAgLy8vIHByaW50cyBvdXQgdGhlIGhpdE1hcFxuICAgIGNvbnNvbGUubG9nKFsuLi5oaXRNYXBdKTsgXG4gICAgcmwuY2xvc2UoKTtcbn0pO1xuXG4iXX0=